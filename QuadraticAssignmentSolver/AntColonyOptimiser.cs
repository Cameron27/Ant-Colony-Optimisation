using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace QuadraticAssignmentSolver
{
    public class AntColonyOptimiser
    {
        /// <summary>
        ///     The exponent for contribution of fitness.
        /// </summary>
        public static double FitnessWeight = 3;

        /// <summary>
        ///     The exponent for contribution of pheromone.
        /// </summary>
        public static double PheromoneWeight = 2;

        /// <summary>
        ///     A random object to be used when a source of randomness is needed.
        /// </summary>
        [ThreadStatic] private static Random _rnd;

        /// <summary>
        ///     The problem being solved.
        /// </summary>
        private readonly Problem _problem;

        /// <summary>
        ///     Initialise a new instance of the <code>AntColonyOptimiser</code> class for a specific problem.
        /// </summary>
        /// <param name="filename">The file containing the problem to be solved.</param>
        public AntColonyOptimiser(string filename)
        {
            _problem = Problem.CreateFromFile(filename);
        }

        /// <summary>
        ///     Perform a search of the solution space using the ACO algorithm.
        /// </summary>
        /// <param name="antCount">The number of ants to use in the search.</param>
        /// <param name="stopThreshold">The number of iterations without any improvement to stop after.</param>
        /// <returns>The best solution found.</returns>
        public Solution Search(int antCount, double stopThreshold)
        {
            PheromoneTable pheromoneTable = new PheromoneTable(_problem);

            Solution best = null;

            // While the stop condition has not been reached
            int iterationsNoImprovement = 0;
            while (iterationsNoImprovement < stopThreshold)
            {
                // Generate solutions with ants and local search
                List<Solution> results = new List<Solution>();
                for (int j = 0; j < antCount; j++) results.Add(LocalSearch(ConstructAntSolution(pheromoneTable)));

                Solution oldBest = best;

                // Set new best solution
                foreach (Solution result in results)
                    if (best == null || result.Fitness < best.Fitness)
                        best = result;

                // Add best solution to the results if it is not already in there
                if (oldBest != null && oldBest.Fitness == best.Fitness)
                {
                    results.Add(best);
                    iterationsNoImprovement++;
                }
                else
                {
                    iterationsNoImprovement = 0;
                }

                // Deposit pheromones
                pheromoneTable.DepositPheromones(results);
            }

            return best;
        }

        /// <summary>
        ///     Construct a solution with an ant.
        /// </summary>
        /// <param name="pheromoneTable">The pheromone table to use in the construction.</param>
        /// <returns>The solution generated by the ant.</returns>
        private Solution ConstructAntSolution(PheromoneTable pheromoneTable)
        {
            _rnd ??= new Random();

            List<int> remainingLocations = Enumerable.Range(0, _problem.Size).ToList();
            List<int> remainingFacilities = Enumerable.Range(0, _problem.Size).ToList();

            Solution solution = new Solution(_problem);

            // While there are unfilled locations
            while (remainingLocations.Count != 0)
            {
                // Select a random location
                int location = remainingLocations[_rnd.Next(remainingLocations.Count)];

                double[] weightings = new double[remainingFacilities.Count];

                // Calculate weighting for each facility
                for (int i = 0; i < remainingFacilities.Count; i++)
                {
                    int facility = remainingFacilities[i];

                    // Calculate the fitness diff for each facility if it were to be inserted at the location
                    solution.SetFacility(location, facility);
                    double fitness = 1d / solution.PartialFitness(location);

                    // Get pheromone for facility at that location
                    double pheromone = pheromoneTable.GetPheromones(location, facility);

                    // Calculate weighting
                    weightings[i] = Math.Pow(fitness, FitnessWeight) * Math.Pow(pheromone, PheromoneWeight);
                }

                // Select a facility with weightings as probabilities
                double weightingSum = weightings.Sum();
                double r = _rnd.NextDouble() * weightingSum;
                int index;
                for (index = 0; index < weightings.Length - 1; index++)
                {
                    r -= weightings[index];
                    if (r <= 0) break;
                }

                // Set facility to chosen facility
                solution.SetFacility(location, remainingFacilities[index]);

                // Update remaining
                remainingLocations.Remove(location);
                remainingFacilities.RemoveAt(index);
            }

            return solution;
        }

        /// <summary>
        ///     Perform a local search on a solution.
        /// </summary>
        /// <param name="solution">The solution to perform the local search on.</param>
        /// <returns>The solution found by local search.</returns>
        private Solution LocalSearch(Solution solution)
        {
            solution = solution.Clone();

            // Iterate local search
            while (true)
            {
                // Want to find best facility swap to minimise fitness
                int bestFitnessDiff = int.MaxValue;
                (int LocationA, int LocationB) bestSwap = (0, 0);

                // For each facility
                for (int locationA = 0; locationA < solution.Size; locationA++)
                {
                    int facilityA = solution.GetFacility(locationA);

                    // Get partial fitness for that facility
                    int partialFitnessA = solution.PartialFitness(locationA);

                    // Remove facility
                    solution.SetFacility(locationA, null);

                    // For each other facility
                    for (int locationB = locationA + 1; locationB < solution.Size; locationB++)
                    {
                        int facilityB = solution.GetFacility(locationB);

                        // Get partial fitness for that facility
                        int partialFitnessB = solution.PartialFitness(locationB);

                        // Set location B to have facility A and get its partial fitness
                        solution.SetFacility(locationB, facilityA);
                        int partialFitnessC = solution.PartialFitness(locationB);

                        // Set location A to have facility B and get its partial fitness
                        solution.SetFacility(locationA, facilityB);
                        int partialFitnessD = solution.PartialFitness(locationA);

                        // Calculate fitness diff and check if it is better
                        int fitnessDiff = -partialFitnessA - partialFitnessB + partialFitnessD + partialFitnessC;
                        if (fitnessDiff < bestFitnessDiff)
                        {
                            bestFitnessDiff = fitnessDiff;
                            bestSwap = (locationA, locationB);
                        }

                        // Reset location B
                        solution.SetFacility(locationA, null);
                        solution.SetFacility(locationB, facilityB);
                    }

                    // Reset location A
                    solution.SetFacility(locationA, facilityA);
                }

                // If no improvement was found, end local search
                if (bestFitnessDiff >= 0) break;

                // Make best swap
                (int lA, int lB) = bestSwap;
                (int fA, int fB) = (solution.GetFacility(lA), solution.GetFacility(lB));
                solution.SetFacility(lA, fB);
                solution.SetFacility(lB, fA);
            }

            return solution;
        }

        /// <summary>
        ///     Perform a search of the solution space using the ACO algorithm multiple times in parallel.
        /// </summary>
        /// <param name="antCount">The number of ants to use in the search.</param>
        /// <param name="stopThreshold">The number of iterations without any improvement to stop after.</param>
        /// <param name="threads">The number of threads to use.</param>
        /// <returns>The best solution found.</returns>
        public Solution SynchronousParallelSearch(int antCount, double stopThreshold, int threads)
        {
            // Spawn a thread for each search and save result
            ConcurrentBag<Solution> results = new ConcurrentBag<Solution>();
            Parallel.For(0, threads, new ParallelOptions {MaxDegreeOfParallelism = Math.Min(Environment.ProcessorCount, threads)},
                _ =>
                {
                    Solution result = Search(antCount, stopThreshold);
                    results.Add(result);
                });

            // Get best result
            Solution bestResult = null;
            int bestFitness = int.MaxValue;
            foreach (Solution result in results)
            {
                int fitness = result.Fitness;

                if (fitness >= bestFitness) continue;

                bestResult = result;
                bestFitness = fitness;
            }

            return bestResult;
        }
    }
}