using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace QuadraticAssignmentSolver
{
    public class AntColonyOptimiser
    {
        /// <summary>
        ///     The exponent for contribution of fitness.
        /// </summary>
        public static double FitnessWeight = 1;

        /// <summary>
        ///     The exponent for contribution of pheromone.
        /// </summary>
        public static double PheromoneWeight = 1;

        /// <summary>
        ///     A random object to be used when a source of randomness is needed.
        /// </summary>
        [ThreadStatic] private static Random _rnd;

        /// <summary>
        ///     The problem being solved.
        /// </summary>
        private readonly Problem _problem;

        /// <summary>
        ///     Initialise a new instance of the <code>AntColonyOptimiser</code> class for a specific problem.
        /// </summary>
        /// <param name="filename">The file containing the problem to be solved.</param>
        public AntColonyOptimiser(string filename)
        {
            _problem = Problem.CreateFromFile(filename);
        }

        /// <summary>
        ///     Perform a search of the solution space using the ACO algorithm.
        /// </summary>
        /// <param name="antCount">The number of ants to use in the search.</param>
        /// <param name="stopThreshold">The number of iterations without any improvement to stop after.</param>
        /// <param name="threads">The number of threads to use when generating solutions.</param>
        /// <returns>The best solution found.</returns>
        public Solution Search(int antCount, double stopThreshold, int threads = 1)
        {
            PheromoneTable pheromoneTable = new PheromoneTable(_problem);

            Solution best = null;

            // While the stop condition has not been reached
            int iterationsNoImprovement = 0;
            while (iterationsNoImprovement < stopThreshold)
            {
                IEnumerable<Solution> results;

                // Run concurrent if thread count it 1
                if (threads == 1)
                {
                    // Generate solutions with ants and local search
                    List<Solution> res = new List<Solution>();
                    for (int j = 0; j < antCount; j++) res.Add(LocalSearch(ConstructAntSolution(pheromoneTable)));
                    results = res;
                }
                else
                {
                    // Generate solutions with ants and local search in parallel
                    ConcurrentBag<Solution> res = new ConcurrentBag<Solution>();
                    Parallel.For(0, antCount, new ParallelOptions {MaxDegreeOfParallelism = threads},
                        _ => res.Add(LocalSearch(ConstructAntSolution(pheromoneTable))));
                    results = res;
                }

                Solution oldBest = best;

                // Set new best solution
                foreach (Solution result in results)
                    if (best == null || result.Fitness < best.Fitness)
                        best = result;

                // Add best solution to the results if it is not already in there
                if (oldBest != null && oldBest.Fitness == best.Fitness)
                {
                    results = results.Append(best);
                    iterationsNoImprovement++;
                }
                else
                {
                    iterationsNoImprovement = 0;
                }

                // Deposit pheromones
                pheromoneTable.DepositPheromones(results);
            }
            
            return best;
        }

        /// <summary>
        ///     Construct a solution with an ant.
        /// </summary>
        /// <param name="pheromoneTable">The pheromone table to use in the construction.</param>
        /// <returns>The solution generated by the ant.</returns>
        private Solution ConstructAntSolution(PheromoneTable pheromoneTable)
        {
            _rnd ??= new Random();

            List<int> remainingLocations = Enumerable.Range(0, _problem.Size).ToList();
            List<int> remainingFacilities = Enumerable.Range(0, _problem.Size).ToList();

            Solution solution = new Solution(_problem);

            // While there are unfilled locations
            while (remainingLocations.Count != 0)
            {
                // Select a random location
                int location = remainingLocations[_rnd.Next(remainingLocations.Count)];

                double[] weightings = new double[remainingFacilities.Count];

                // Calculate weighting for each facility
                for (int i = 0; i < remainingFacilities.Count; i++)
                {
                    int facility = remainingFacilities[i];

                    // Calculate the fitness diff for each facility if it were to be inserted at the location
                    solution.SetFacility(location, facility);
                    double fitness = 1d / solution.PartialFitness(location);

                    // Get pheromone for facility at that location
                    double pheromone = pheromoneTable.GetPheromones(location, facility);

                    // Calculate weighting
                    weightings[i] = Math.Pow(fitness, FitnessWeight) * Math.Pow(pheromone, PheromoneWeight);
                }

                // Select a facility with weightings as probabilities
                double weightingSum = weightings.Sum();
                double r = _rnd.NextDouble() * weightingSum;
                int index;
                for (index = 0; index < weightings.Length - 1; index++)
                {
                    r -= weightings[index];
                    if (r <= 0) break;
                }

                // Set facility to chosen facility
                solution.SetFacility(location, remainingFacilities[index]);

                // Update remaining
                remainingLocations.Remove(location);
                remainingFacilities.RemoveAt(index);
            }

            return solution;
        }

        /// <summary>
        ///     Perform a local search on a solution.
        /// </summary>
        /// <param name="solution">The solution to perform the local search on.</param>
        /// <returns>The solution found by local search.</returns>
        public static Solution LocalSearch(Solution solution)
        {
            solution = solution.Clone();

            // Calculate all partial fitnesses
            int[] partialFitnesses = solution.AllPartialFitnesses();

            // Iterate local search
            while (true)
            {
                // Want to find best facility swap to minimise fitness
                int bestFitnessDiff = int.MaxValue;
                (int LocationA, int LocationB) bestSwap = (0, 0);

                // For each facility
                for (int locationA = 0; locationA < solution.Size; locationA++)
                {
                    int facilityA = solution.GetFacility(locationA);

                    // Get partial fitness for that facility
                    int partialFitnessA = partialFitnesses[locationA];

                    // For each other facility
                    for (int locationB = locationA + 1; locationB < solution.Size; locationB++)
                    {
                        int facilityB = solution.GetFacility(locationB);

                        // Get partial fitness for that facility
                        int partialFitnessB = partialFitnesses[locationB];

                        // Note: partialFitnessA and partialFitnessB together double count the AB link but that is later
                        // canceled out by partialFitnessC and partialFitnessD also double counting it

                        // Swap facilities
                        solution.SetFacility(locationB, facilityA);
                        solution.SetFacility(locationA, facilityB);

                        int partialFitnessC = solution.PartialFitness(locationB);
                        int partialFitnessD = solution.PartialFitness(locationA);

                        // Calculate fitness diff and check if it is better
                        int fitnessDiff = -partialFitnessA - partialFitnessB + partialFitnessD + partialFitnessC;
                        if (fitnessDiff < bestFitnessDiff)
                        {
                            bestFitnessDiff = fitnessDiff;
                            bestSwap = (locationA, locationB);
                        }

                        // Reset location B
                        solution.SetFacility(locationA, facilityA);
                        solution.SetFacility(locationB, facilityB);
                    }

                    // Reset location A
                    solution.SetFacility(locationA, facilityA);
                }

                // If no improvement was found, end local search
                if (bestFitnessDiff >= 0) break;

                {
                    // Extract values
                    (int locationA, int locationB) = bestSwap;
                    (int facilityA, int facilityB) = (solution.GetFacility(locationA), solution.GetFacility(locationB));

                    // Update partial fitnesses by removing location A and B
                    for (int location = 0; location < partialFitnesses.Length; location++)
                    {
                        if (location == locationA || location == locationB) continue;
                        partialFitnesses[location] -= solution.PartialFitness(location, locationA);
                        partialFitnesses[location] -= solution.PartialFitness(location, locationB);
                    }

                    // Make swap
                    solution.SetFacility(locationA, facilityB);
                    solution.SetFacility(locationB, facilityA);

                    // Update partial fitnesses by adding new location A and B
                    for (int location = 0; location < partialFitnesses.Length; location++)
                    {
                        if (location == locationA || location == locationB) continue;
                        partialFitnesses[location] += solution.PartialFitness(location, locationA);
                        partialFitnesses[location] += solution.PartialFitness(location, locationB);
                    }

                    // Recalculate partial fitness for location A and B
                    partialFitnesses[locationA] = solution.PartialFitness(locationA);
                    partialFitnesses[locationB] = solution.PartialFitness(locationB);
                }
            }

            return solution;
        }

        /// <summary>
        ///     Perform a search of the solution space using the ACO algorithm multiple times in parallel.
        /// </summary>
        /// <param name="antCount">The number of ants to use in the search.</param>
        /// <param name="stopThreshold">The number of iterations without any improvement to stop after.</param>
        /// <param name="threads">The number of threads to use.</param>
        /// <returns>The best solution found.</returns>
        public Solution ReplicatedParallelSearch(int antCount, double stopThreshold, int threads)
        {
            // Spawn a thread for each search and save result
            ConcurrentBag<Solution> globalResults = new ConcurrentBag<Solution>();
            Parallel.For(0, threads,
                new ParallelOptions {MaxDegreeOfParallelism = threads},
                _ =>
                {
                    Solution result = Search(antCount, stopThreshold);
                    globalResults.Add(result);
                });

            // Get best result
            Solution bestResult = null;
            int bestFitness = int.MaxValue;
            foreach (Solution result in globalResults)
            {
                int fitness = result.Fitness;

                if (fitness >= bestFitness) continue;

                bestResult = result;
                bestFitness = fitness;
            }

            return bestResult;
        }

        /// <summary>
        ///     Perform a search of the solution space using the ACO algorithm with solutions generated in parallel.
        /// </summary>
        /// <param name="antCount">The number of ants to use in the search.</param>
        /// <param name="stopThreshold">The number of iterations without any improvement to stop after.</param>
        /// <param name="threads">The number of threads to use.</param>
        /// <returns>The best solution found.</returns>
        public Solution SynchronousParallelSearch(int antCount, double stopThreshold, int threads)
        {
            return Search(antCount, stopThreshold, threads);
        }

        public Solution CourseGrainedSearch(int antCount, int stopThreshold, int threads)
        {
            ConcurrentBag<Solution> globalResults = new ConcurrentBag<Solution>();

            // Create pheromone tables
            PheromoneTable[] pheromoneTables = new PheromoneTable[threads];
            for (int i = 0; i < threads; i++) pheromoneTables[i] = new PheromoneTable(_problem);
            ManualResetEvent[] events1 = new ManualResetEvent[threads];
            ManualResetEvent[] events2 = new ManualResetEvent[threads];
            for (int i = 0; i < threads; i++) events1[i] = new ManualResetEvent(false);
            for (int i = 0; i < threads; i++) events2[i] = new ManualResetEvent(false);
            AutoResetEvent event1 = new AutoResetEvent(false);
            AutoResetEvent event2 = new AutoResetEvent(false);

            List<int> remainingThreads = Enumerable.Range(0, threads).ToList();

            bool terminateSupervisor = false;
            object terminateSupervisorLock = new object();
            Thread t = new Thread(Supervisor);
            t.Start();

            Parallel.For(0, threads, new ParallelOptions {MaxDegreeOfParallelism = threads}, index =>
            {
                Solution best = null;

                // While the stop condition has not been reached
                int iterationsNoImprovement = 0;
                int c = 0;
                while (true)
                {
                    // Generate solutions with ants and local search
                    List<Solution> res = new List<Solution>();
                    for (int j = 0; j < antCount; j++)
                        res.Add(LocalSearch(ConstructAntSolution(pheromoneTables[index])));

                    IEnumerable<Solution> results = res;

                    Solution oldBest = best;

                    // Set new best solution
                    foreach (Solution result in results)
                        if (best == null || result.Fitness < best.Fitness)
                            best = result;

                    // Add best solution to the results if it is not already in there
                    if (oldBest != null && oldBest.Fitness == best.Fitness)
                    {
                        results = results.Append(best);
                        iterationsNoImprovement++;
                    }
                    else
                    {
                        iterationsNoImprovement = 0;
                    }

                    // Deposit pheromones
                    pheromoneTables[index].DepositPheromones(results);
                    c++;

                    if (c % stopThreshold != 0) continue;

                    if (iterationsNoImprovement == stopThreshold) break;

                    // Synchronise all running threads at this point
                    events1[index].Set();
                    event1.WaitOne();
                    events1[index].Reset();

                    if (index == remainingThreads[0])
                    {
                        double[] newPheromones = new double[_problem.Size * _problem.Size];
                        foreach (PheromoneTable pheromoneTable in pheromoneTables)
                        {
                            double[] pheromones = pheromoneTable.GetAllPheromones();
                            for (int i = 0; i < pheromones.Length; i++) newPheromones[i] += pheromones[i] / threads;
                        }

                        foreach (PheromoneTable pheromoneTable in pheromoneTables)
                            pheromoneTable.SetAllPheromones(newPheromones);
                    }

                    iterationsNoImprovement = 0;

                    // Synchronise all running threads at this point
                    events2[index].Set();
                    event2.WaitOne();
                    events2[index].Reset();
                }

                remainingThreads.Remove(index);

                // Make this thread no longer block
                events1[index].Set();
                events2[index].Set();

                // Output best result
                globalResults.Add(best);
            });

            events1[0].Reset();
            lock (terminateSupervisorLock)
            {
                terminateSupervisor = true;
            }

            // Get best result
            Solution bestResult = null;
            int bestFitness = int.MaxValue;
            foreach (Solution result in globalResults)
            {
                int fitness = result.Fitness;

                if (fitness >= bestFitness) continue;

                bestResult = result;
                bestFitness = fitness;
            }

            return bestResult;

            // A method to run as a thread that will allow each thread to continue when they all reach the
            // synchronisation points
            void Supervisor()
            {
                while (true)
                    if (WaitHandle.WaitAll(events1, 100))
                    {
                        event2.Reset();
                        for (int i = 0; i < threads; i++) event1.Set();

                        WaitHandle.WaitAll(events2);
                        event1.Reset();
                        for (int i = 0; i < threads; i++) event2.Set();
                    }
                    else
                    {
                        lock (terminateSupervisorLock)
                        {
                            if (!terminateSupervisor) continue;

                            return;
                        }
                    }
            }
        }
    }
}